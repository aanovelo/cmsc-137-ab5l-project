#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Asymmetric Ciphers
\end_layout

\begin_layout Standard
Cryptographic systems rely on keys for encryption and decryption.
 Traditionally, a single key is required to encrypt and to decrypt.
 In order for the recipient of the encrypted message to be decrypted by
 the recipient, the key must also be transmitted.
 However, sending the key over the channel (normal channel) where the actual
 message will be sent is insecure.
 The key must be transmitted on a different and secure channel (key channel)
\begin_inset CommandInset citation
LatexCommand cite
key "merkle_secure_1978"

\end_inset

.
 This secure channel where the key should be transmitted cannot be used
 for normal transmission because it is costly and sometimes difficult for
 users to access and use
\begin_inset CommandInset citation
LatexCommand cite
key "merkle_secure_1978"

\end_inset

.
 This begs the question whether it is possible to send encrypted messages
 in such a way that the key can also be transmitted over the normal (insecure)
 channel and still achieve secure communication.
 In this section, we focus on solving this problem by describing the relevant
 and important work on asymmetric ciphers.
 Firgure 1 describes the flow in asymmetric cryptography.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Flow of messages from source to destination.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename flowchart1.png
	scale 45
	rotateOrigin center

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Merkle(1978)
\begin_inset CommandInset citation
LatexCommand cite
key "merkle_secure_1978"

\end_inset


\end_layout

\begin_layout Standard
Secure communication, as described by Merkle
\begin_inset CommandInset citation
LatexCommand cite
key "merkle_secure_1978"

\end_inset

, allows two parties to communicate in a private manner even though a third
 party tries its best to learn what is being communicated.
 We refer to the two parties as Froi and Shiela, and the third party as
 Jade (Figure 1).
 Since the key channel is important, the following describes the characteristics
 of the channel in relation to Jade.
\end_layout

\begin_layout Enumerate
All attempts by Jade to change the messages on the key channel are detectable.
\end_layout

\begin_layout Enumerate
Jade will not be able to know the actual content of any message passing
 on the key channel.
\end_layout

\begin_layout Standard
The approach by Merkle relaxes the second condition: It is not necessary
 for Jade not to know what is being sent in the key channel, he can even
 know everything passing on it.
 The challenge then is how to securely distribute the key satisfying the
 conditions above.
 If Froi and Shiela have agreed upon a key, and the work needed by Jade
 to find the key is much higher than the effort by Froi and Shiela needed
 to generate the key , then it is a solution.
 The effort by Jade should be exponentially higher compared to the effort
 by Froi or Shiela for a method to be considered a solution.
 
\end_layout

\begin_layout Standard
Merkle's method uses the concept of puzzles
\begin_inset CommandInset citation
LatexCommand cite
key "merkle_secure_1978"

\end_inset

.
 A puzzle is a cryptogram that is meant to be solved.
 Any encryption function can be used to generate a puzzle.
 To allow the puzzle to be solved, the key size (N) used in the encryption
 function is restricted.
 The difficulty of solving a puzzle can be controlled by adjusting the size
 of N.
 A very large size (in bits) of N will make it very difficult to solve the
 puzzle.
 In addition, in order to be able to solve the puzzle, some redundancy is
 needed.
 Redundancy is introduced by encrypting, along with the original message,
 some constant known to Froi, Shiela, and Jade.
 The absence of the constant when a puzzle is decrypted would mean that
 a wrong key has been used.
 
\end_layout

\begin_layout Standard
Let us consider the scenario when Shiela wishes to send a message to Froi.
 First, they both agree on the value of N to use.
 Shiela then generates N puzzles and transmits these N puzzles to Froi using
 the key channel.
 Each puzzle generated will have a puzzle ID and puzzle key.
 The puzzle ID uniquely identifies each puzzle.
 The puzzle key on the other hand will be used in future communications
 that will happen once this puzzle has been solved.
 
\end_layout

\begin_layout Standard
When Froi receives the N puzzles, he selects a puzzle at random and attempts
 to solve the puzzle, with the amount of effort required, as defined by
 the size of the key space specified by Shiela.
 After solving a puzzle, Froi sends the puzzle ID back to Shiela using the
 key channel.
 The puzzle key, associated with the puzzle ID sent by Froi, is then used
 for future communications, this time over the normal channel.
 At this point Jade knows the puzzle ID, since it was sent using the key
 channel, but not the puzzle key.
 If Jade wants to know the key, then he must solve puzzles randomly and
 check the puzzle ID if it matches the one sent by Froi back to Shiela.
 This will take Jade a long time to solve.
 To put it formally, Jade will require 
\begin_inset Formula $O(N^{2})$
\end_inset

 effort to determine the key whereas Froi will only need, on the average,
 
\begin_inset Formula $O(N)$
\end_inset

.
 The function below generates the puzzles sent by Shiela to Froi.
 The encryption function is arbitrary.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

void generate_puzzle()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   bit_string id, key, c, random_key, puzzle, k1, k2;
\end_layout

\begin_layout Plain Layout

   int i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   k1 = rand(MAXINT);
\end_layout

\begin_layout Plain Layout

   k2 = rand(MAXINT);
\end_layout

\begin_layout Plain Layout

   c = rand(MAXINT);
\end_layout

\begin_layout Plain Layout

   send(c);
\end_layout

\begin_layout Plain Layout

   for (i=0; i<N; i++)
\end_layout

\begin_layout Plain Layout

   {
\end_layout

\begin_layout Plain Layout

      id = encryption_function(k1,i);
\end_layout

\begin_layout Plain Layout

      key = encryption_function(k2, i);
\end_layout

\begin_layout Plain Layout

      random_key = rand(c*N);
\end_layout

\begin_layout Plain Layout

      puzzle = encryption_function(random_key,id,key,c);
\end_layout

\begin_layout Plain Layout

      send(puzzle);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code below is executed on Froi's side.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

void get_id()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   bit_string id, key, c, selected_puzzle_id, the_puzzle, current_puzzle,
\end_layout

\begin_layout Plain Layout

              temp_constant;
\end_layout

\begin_layout Plain Layout

   int i;
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   selected_puzzle_id = rand(N);
\end_layout

\begin_layout Plain Layout

   receive(c);
\end_layout

\begin_layout Plain Layout

   for (i=0; i<N; i++)
\end_layout

\begin_layout Plain Layout

   {
\end_layout

\begin_layout Plain Layout

      receive(currrent_puzzle);
\end_layout

\begin_layout Plain Layout

      if (i == selected_puzzle_id)
\end_layout

\begin_layout Plain Layout

         the_puzzle = current_puzzle;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   for (i=0;i<(c*N);i++)
\end_layout

\begin_layout Plain Layout

   {
\end_layout

\begin_layout Plain Layout

      id = get_id(finverse(i, the_puzzle));  
\end_layout

\begin_layout Plain Layout

      key = get_key(finverse(i, the_puzzle));
\end_layout

\begin_layout Plain Layout

      temp_constant = get_constant(finverse(i, the_puzzle));
\end_layout

\begin_layout Plain Layout

      if (temp_constant == c)
\end_layout

\begin_layout Plain Layout

         send(id);
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once Shiela receives the the puzzle ID from Froi, then the following code
 will be executed.
 key will be used for subsequent communications between the two.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily},language=C"
inline false
status open

\begin_layout Plain Layout

void continue_transmission()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   receive(ID);
\end_layout

\begin_layout Plain Layout

   key = encryption_function(k2, ID);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The approach by Merkle requires an effort of 
\begin_inset Formula $O(N^{2})$
\end_inset

 from Jade to get the key.
 However, in todays available computing resources, this can be easily broken.
 The possibility of exponential methods will be more attractive.
 Also the amount of information sent during the initial setup of the communicati
on is large because N puzzles, consequently N keys, are sent initially.
\end_layout

\begin_layout Subsection
Diffie-Helman(1976)
\begin_inset CommandInset citation
LatexCommand cite
key "diffie_new_1976"

\end_inset


\end_layout

\begin_layout Standard
The work by Diffie and Helman
\begin_inset CommandInset citation
LatexCommand cite
key "diffie_new_1976"

\end_inset

 proposed a method such that only one 
\begin_inset Quotes eld
\end_inset

key
\begin_inset Quotes erd
\end_inset

 needs to be exchanged and in addition the time required from Jade to perform
 cryptanalysis is exponential.
 In addition, it allows authentication because its use allows it to be tied
 to a public file of user information.
 Shiela can authenticate Froi and vice versa.
 
\end_layout

\begin_layout Standard
Diffie and Helman differentiate public key cryptosystems and public key
 distribution systems.
 We let 
\begin_inset Formula ${K}$
\end_inset

 be the finite key space from which keys 
\begin_inset Formula $K$
\end_inset

 can be obtained and 
\begin_inset Formula ${M}$
\end_inset

 be the finite message space where messages 
\begin_inset Formula $M$
\end_inset

 are derived.
 A public key cryptosystem is a pair of families of algorithms 
\begin_inset Formula ${E_{k}}$
\end_inset

 and
\begin_inset Formula ${D_{k}}$
\end_inset

 which represent invertible transformations
\begin_inset CommandInset citation
LatexCommand cite
key "diffie_new_1976"

\end_inset

.
 
\begin_inset Formula 
\[
E_{k}:\{M\}\rightarrow\{M\}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
D_{k}:\{M\}\rightarrow\{M\}
\]

\end_inset


\end_layout

\begin_layout Standard
such that 
\end_layout

\begin_layout Enumerate
for every key 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $E_{k}$
\end_inset

 is the inverse of 
\begin_inset Formula $D_{k}$
\end_inset

,
\end_layout

\begin_layout Enumerate
for every 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, the algorithms 
\begin_inset Formula $E_{k}$
\end_inset

 and 
\begin_inset Formula $D_{k}$
\end_inset

 are easy to compute,
\end_layout

\begin_layout Enumerate
for almost every 
\begin_inset Formula $K$
\end_inset

, each easily computed algorithm equivalent to 
\begin_inset Formula $D_{k}$
\end_inset

 is computationally infeasible to derive from 
\begin_inset Formula $E_{k}$
\end_inset

,
\end_layout

\begin_layout Enumerate
for every 
\begin_inset Formula $K$
\end_inset

, it is feasible to compute inverse pairs 
\begin_inset Formula $E_{k}$
\end_inset

 and 
\begin_inset Formula $D_{k}$
\end_inset

 from 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Standard
Property 3 allows 
\begin_inset Formula $E_{k}$
\end_inset

 to be made public without compromising 
\begin_inset Formula $D_{k}$
\end_inset

.
 Key distribution in this system is simplified.
 Users generate two keys, an enciphering key 
\begin_inset Formula $E$
\end_inset

 and a deciphering key 
\begin_inset Formula $D$
\end_inset

.
 
\begin_inset Formula $E$
\end_inset

 can be made public but 
\begin_inset Formula $D$
\end_inset

 is kept privately by the user.
 Any entity who would like to send messages to a user can use the publicly
 available 
\begin_inset Formula $E$
\end_inset

 to encrypt messages but only the user can decrypt the message using 
\begin_inset Formula $D$
\end_inset

.
 In their paper, Diffie and Helman gave an example public key cryptosystem
 by multiplying a binary n-vector message m with an invertible binary n
 x n matrix E.
 However, this approach is not practical.
\end_layout

\begin_layout Standard
Merkle's
\begin_inset CommandInset citation
LatexCommand cite
key "merkle_secure_1978"

\end_inset

 work was classified by Diffie and Helman as public key distribution system
 and highlighted its limitations specifically its high transmission overhead
 again because of sending N puzzles initially.
 The proposed system is similar to the public key cryptosystem described
 above, but unlike Merkle's technique, Diffie and Helman approach allows
 the authentication of users by making the public file read-only
\begin_inset CommandInset citation
LatexCommand cite
key "diffie_new_1976"

\end_inset

.
 
\end_layout

\begin_layout Standard
The technique proposed is dependent on the difficulty of computing logarithms
 mod q where q is a prime number representing the number of elements of
 a finite field.
 Users generate independent random numbers 
\begin_inset Formula $X_{i}$
\end_inset

 from the set of integers 
\begin_inset Formula ${1,2,...,q-1}$
\end_inset

.
 The users keep these numbers but the computed value 
\begin_inset Formula 
\[
Y_{i}=\alpha^{X_{i}}modq
\]

\end_inset


\end_layout

\begin_layout Standard
is placed publicly together with the user information.
\end_layout

\begin_layout Subsection
Rivest-Shamir-Adleman(1978)
\begin_inset CommandInset citation
LatexCommand cite
key "rivest_method_1978"

\end_inset


\end_layout

\begin_layout Subsection
Elgamal(1985)
\begin_inset CommandInset citation
LatexCommand cite
key "elgamal_public_1985"

\end_inset


\end_layout

\begin_layout Subsection
Elliptic Curve Cryptosystems(1987)
\begin_inset CommandInset citation
LatexCommand cite
key "koblitz_elliptic_1987"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "asymmetric"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
