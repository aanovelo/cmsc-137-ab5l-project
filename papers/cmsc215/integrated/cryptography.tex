\documentclass[10pt, twocolumn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{algpseudocode}

\title{Cryptography}
\author{Shiela Kathleen L. Borja\\Joseph Anthony C. Hermocilla\\Mark Froilan B. Tandoc}
\date{}


\begin{document}
\maketitle

\section{Introduction}
Cryptography is an area of study of encryption of plaintext to a so called ciphertext. Cryptographic systems are characterized along three independent dimensions. First is the type of operations used for transforming plaintext to ciphertext. All encryption algorithms are based on two general principles: \textit{substitution} where each element in the plaintext is mapped into another element, and \textit{transposition} where elements in the plaintext are rearranged. Second is the number of keys used. If both sender and receiver use the same key, the system is referred to as \textit{symmetric}, single-key, secret-key, or conventional encryption. If the sender and receiver use different keys, the system is referred to as \textit{asymmetric}, two-key, or public-key encryption. Last dimension is the way in which the plaintext is processed. A \textit{block cipher} processes the input one block of elements at a time, producing an output block for each input block. A \textit{stream cipher} processes the input elements continuously, producing output one element at a time \cite{stallings2011}.

There are two types of attack on an encryption algorithm. \textit{Cryptanalysis} is based on properties of the encryption algorithm and \textit{brute-force} which involves trying all possible keys.

\section{Classical Encryption Techniques}
\subsection{Caesar Cipher}
The earliest and simplest known substitution cipher by Julius Caesar \cite{stallings2011}. This cipher involves replacing each letter of the alphabet with the letter standing three places (or even more for the general algorithm) further down the alphabet. The alphabet is wrapped around where Z follows A. For example:
\\

\begin{tabular}{r l}
	plain: & COMSCI IS THE BEST\\
	cipher: & FRPVFL LV WKH EHVW
\end{tabular}
\\

If the attacker knew that Caesar cipher was used, brute-force cryptanalysis is easily performed and there are only 25 keys to try.

\subsection{Monoalphabetic Cipher}
It was shown that Caesar cipher is far from secure. The key space can be dramatically increased if we allow arbitrary substitution for each letter/character. With this, the number of possible keys is increased from 25 to the number of permutations for the given alphabet or 26! possible keys. There is still, however, another possible attack. If the cryptanalyst knew the nature of the plaintext (e.g. noncompressed English text), then he/she can exploit the regularities of the language like relative frequency of the letters in the ciphertext and compare it to the standard frequency distribution for English \cite{stallings2011}.

\subsection{Playfair Cipher}
The Playfair algorithm uses a 5 x 5 matrix of letters constructed using a keyword. The matrix is constructed by filling in the letters of the keyword (minus duplicates) from left to right and from top to bottom. Then filling the remainder of the matrix with the remaining letters in alphabetical order. The letters I and J count as one letter \cite{stallings2011}. For example with keyword \textit{monarchy}:
\\

\begin{tabular}{|c|c|c|c|c|}
\hline
M & O & N & A & R\\
\hline
C & H & Y & B & D\\
\hline
E & F & G & I/J & K\\
\hline
L & P & Q & S & T\\
\hline
U & V & W & X & Z\\
\hline
\end{tabular}
\\

The plaintext is encrypted two letters at a time, according the the rules:
\begin{itemize}
\item Repeating plaintext letters that are in the same pair are separated with a filler letter, such as x, so that balloon would be treated as ba lx lo on.
\item Two plaintext letters that fall in the same row of the matrix are each replaced by the letter to the right, withe first element of the row circularly following the last. For example, ar is encrypted as RM.
\item Two plaintext letters that fall in the same column are each replaced by the letter beneath, with the top element of the column circularly following the last. For example, mu is encrypted as CM.
\item Otherwise, each plaintext letter in a pair is replaced by the letter that lies in its own row and the column occupied by the other plaintext letter. Thus, hs becomes BP and ea becomes IM/JM.
\end{itemize}

The Playfair cipher is a great advancement over monoalphabetic ciphers. However, despite this level of confidence in its security, it is still relatively easy to break because it still leaves much structure of the plaintext language intact.

\subsection{Polyalphabetic Cipher}
Another way to improve monoalphabetic technique is to use different monoalphabetic substitutions through encryption of the plaintext message. The general name of the technique is polyalphabetic substitution cipher \cite{stallings2011}.

The best known and one of the simplest is the \textbf{Vigen\`{e}re cipher}. It is essentially multiple caesar ciphers. For every letter in the plaintext, we use one letter at a time of the secret key as the key to apply for the Caesar cipher. For example:
\\

\begin{tabular}{l l}
key: & deceptivedeceptive\\
plaintext: & wearediscoveredsav\\
ciphertext: & ZICVTWQNGRZGVTWAVZ\\
\end{tabular}
\\

When expressed numerically,
\\
\begin{tabular}{| l *{9}{|c} |}
\hline
key & 3 & 4 & 2 & 4 & 15 & 19 & 8 & 21 & 4\\
\hline
plain & 22 & 4 & 0 & 17 & 4 & 3 & 8 & 18 & 2\\
\hline
cipher & 25 & 8 & 2 & 21 & 19 & 22 & 16 & 13 & 6\\
\hline
\hline
key & 3 & 4 & 2 & 4 & 15 & 19 & 8 & 21 & 4\\
\hline
plain & 14 & 21 & 4 & 17 & 4 & 3 & 18 & 0 & 21\\
\hline
cipher & 17 & 25 & 6 & 21 & 19 & 22 & 0 & 21 & 25\\
\hline
\end{tabular}
\\

The length of the key can be derived by observing for repeating sequences in the cipher text. In the example, the sequence VTW occurred twice and it can be used to determine the length of the key which is 9.

To defend on such cryptanalysis, we can choose to have a very long keyword as long as the plaintext and has no statistical relationship to it. It was introduced by an AT\&T engineer Gilbert Vernam in 1918 called \textbf{Vernam Cipher} \cite{stallings2011}.

\subsection{One-Time Pad}
An Army Signal Corp officer named Joseph Mauborgne, improved the Vernam cipher that is said to be unbreakable. The key should be random and as long as the plaintext such that the key is not repeated. Moreover, new messages requires new keys of the same length as the new message. This produces random output with no statistical relationship with the plaintext, therefore no way of breaking the code. However, there are practical difficulties. One is the problem of making large quantities of random keys. Another is the problem of key distribution and protection.

\subsection{Transposition Techniques}
The techniques discussed were all substitution of a ciphertext symbol for a plaintext symbol. A different kind of mapping is by performing some sort of permutation on the plaintext letters. This is referred to as a transposition cipher \cite{stallings2011}.

The simplest of a transposition cipher is the \textbf{rail fence} technique where the plaintext is written down as a sequence of diagonals and then read off as a sequence of rows. For example, the message "\textit{meet me after the toga party}" with a rail fence of depth 2:
\\
\begin{verbatim}
m e m a t r h t g p r y
 e t e f e t e o a a t
\end{verbatim}
will yield the encrypted message:\\
MEMATRHTGPRYETEFETEOAAT

A more complex scheme is to write the message in a matrix and read the message off, column by column, but permute the order of the columns. The order of the columns would then become the key of the algorithm. For example:
\\

\begin{tabular}{l | *{7}{c}}
Key: & 4 & 3 & 1 & 2 & 5 & 6 & 7\\
\hline
Plaintext: & a & t & t & a & c & k & p\\
& o & s & t & p & o & n & e\\
& d & u & n & t & i & l & t\\
& w & o & a & m & x & y & z\\
\end{tabular}
\\

Ciphertext:\\
TTNAAPTMTSUOAODWCOIXKNLYPETZ
\\

The transposition stage can be done repeatedly to have more complex permutation to improve security.

\section{Directions of Cryptography}
\subsection{Symmetric Ciphers}
Symmetric encryption is  where encryption and decryption are performed using the same key. It is also known as conventional encryption \cite{stallings2011}. A symmetric encryption scheme has five parts:

\begin{enumerate}
	\item \textbf{Plaintext:} The original intelligible message or data.
	\item \textbf{Encryption Algorithm:} Performs various substitutions and transformations on the plaintext.
	\item \textbf{Secret Key:} It is also an input for the encryption algorithm. The exact substitutions and transformations performed by the algorithm depend on the key.
	\item \textbf{Ciphertext:} The scrambled message produced as output.
	\item \textbf{Decryption algorithm:} Essentially the encryption algorithm performed in reverse. It takes the ciphertext and the secret key as input and produces the plaintext as output.
\end{enumerate}

Other terms that are used in the sections are:
\begin{enumerate}
	\item \textbf{Field:} A set where the four fundamental operations preserving the closure property.\cite{stallings2011}
	\item \textbf{GF($2^{8}$):} defined as a finite field containing 2n elements.\cite{stallings2011}
	\item \textbf{prop ratio:} the relative amount of all input pairs that for the given input difference give rise to the output difference. \cite{daemen1999}
\end{enumerate}

\subsubsection{Block Ciphers}
Block cipher allows a block of plaintext to be treated as a whole and used to produce a ciphertext block of equal length. The simplest techniques that can be used to encrypt a block of plaintext are substitution and permutation. Substitution replaces a symbol or groups of symbols with a corresponding ciphertext symbols or groups of symbols. Permutation replaces a sequence of plaintext symbols with a permutation of the same set of symbols. \cite{stallings2011}

\subsubsection{Feistel Cipher Structure}
As discussed by Stallings \cite{stallings2011}, the inputs required in the encryption algorithm are the plaintext block of length 2w bits and a key K. The plaintext block is then divided into two halves, $L_{0}$ and $R_{0}$, which pass through n rounds of processing and then combine to create  the ciphertext. In each round, substitution is performed on the left-half block , $L_{0}$. This is done by applying a round function F to the right-half block and then applying XOR to F's output and the left-half block. The round function has the same general structure for each round but is parameterized by the round subkey $K_{i}$. The decryption algorithm for the Feistel cipher is basically the same as the encryption process with the rule: Use the ciphertext as a input to the algorithm, but use subkeys $K_{i}$  in reverse order. In order to ensure that decryption is the inverse of encryption, the final round of a Feistel cipher switches the ciphertext to ($R_{0}$, $L_{0}$). Figure \ref{FeistelEncryptDecrypt} shows the Feistel encryption and decryption processes.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.7]{FeistelEncryptDecrypt.png}
\caption{Feistel Encryption and Decryption}
\label{FeistelEncryptDecrypt}
\end{center}
\end{figure}

\subsubsection{The Data Encryption Standard (DES)}
The Data Encryption Standard is a block cipher encrypts the data in 64b blocks through a 56b key. It is the most widely used public cryptosystem in the world. It is mainly used for electronic funds transfer, civilian satellite communications security, and UNIX password protection.\cite{landau2000} DES was first proposed in 1975 and was adopted by the National Bureau of Standards(NBS) in 1977. DES was approved as the Federal Information Processing Standard 46. \cite{stallings2011}
	The development of DES can be traced back to the development of LUCIFER, a Feistel block cipher that uses 64b blocks and 128b key. LUCIFER became very promising leading IBM, its developers, to launch a new marketable commercial encryption product which can be implemented on a chip. The result of the new project was a more cryptanalysis-secure version of LUCIFER that uses 56b key. In 1973, NBS accepted proposals for a national cipher standard where IBM submitted the refined version of LUCIFER which was later adopted as the Data Encryption Standard.\cite{stallings2011}
	DES came under fire even before its adaptation as a standard due to its enormous key size reduction and its classified design criteria for its internal structure, S-boxes. The critics were concerned that the new key size is vulnerable to brute-force attacks. Also, they were concerned that the classified  design criteria might hide weak points that would enable the National Security Agency(NSA) to decipher messages without the key.\cite{stallings2011} Despite the issues surrounding DES, it remained as a strong  encryption algorithm until the mid 1990s when a USD250,000 computer built by the Electronic Frontier Foundation (EFF) decoded a DES-encoded message in 56 hours. This was later improved to 22 hours using a combination of 100,000 networked PCs and the EFF machine.\cite{landau2000}

\paragraph{DES Encryption}
As discussed by Landau\cite{landau2000}, input to the algorithm are the plaintext grouped into 64b blocks and a single 56b key. First step in the encryption is to rearrange the 64b plaintext to produce a permuted input.  Throughout the whole plaintext, a single 56b key is used to determine the transformation of all the blocks. DES uses a 48b subkey for each of the sixteen identical rounds of mixing. DES begins with  an initial permutation P and ends with its inverse, $P^{-1}$. Selecting the subkeys or “key schedule” begins with splitting the 56b key into two 28b halves. Each half is rotated one or two bits (one bit in rounds 1, 2, 9 and 16; two bits otherwise) then the two halves are put back together, and then the 48 bits are chosen and put in order as follows:

\begin{tabular}{*{6}{|c}|}
\hline
14 & 17 & 11 & 24 & 1 & 5\\
\hline
3 & 28 & 15 & 6 & 21 & 10\\
\hline
23 & 19 & 12 & 4 & 26 & 8\\
\hline
16 & 7 & 27 & 20 & 13 & 2\\
\hline
41 & 52 & 31 & 37 & 47 & 55\\
\hline
30 & 40 & 51 & 45 & 33 & 48\\
\hline
44 & 49 & 39 & 56 & 34 & 53\\
\hline
46 & 42 & 50 & 36 & 29 & 32\\
\hline
\end{tabular}

DES is a standard Feistel construction:\\
$L_{i}=R_{i-1},\\
R_{i}=L-i-1 \, xor \, f(R_{i-1}, K_{i})\\
where\\
f(R_{i-1}, K_{i})=P(S(E(R_{i}-1) \, xor \, K_{i}))\\
with \, the \, operations\\
E(expansion),S(S-boxlookup),P(permutation)
$

The expansion operation E begins with bit 32 and cycles back to the beginning, using all the bits in order, repeating every fourth and fifth bits. E allows every bit of a DES ciphertext to depend on every bit of the plaintext and every bit of the key.\cite{landau2000}

After performing XOR operation on the round subkey and the expanded right half, the result is then passed through the S-boxes. Each of the S-box takes an input of six bits and has an output of four bits. Each of the output of the eight S-boxes is concatenated producing a 32b output.\cite{landau2000}

$P^{1}$, a specific 32b permutation of the S-boxes' output, completes the round function. It carries 1, ..., 32 into the following list:
\begin{tabular}{*{8}{|c}|}
\hline
16 & 7 & 20 & 21 & 29 & 12 & 28 & 17\\
\hline
1 & 15 & 23 & 26 & 5 & 18 & 31 & 10\\
\hline
2 & 8 & 24 & 14 & 32 & 27 & 3 & 9\\
\hline
19 & 13 & 30 & 6 & 22 & 11 & 4 & 25\\
\hline
\end{tabular}

P guarantees that the output from one round of DES affects the input for the multiple S-boxes in the next round. At the end of all the rounds, DES ends with a final exchange of the left and right halves (and then $P^{-1}$).\cite{landau2000} Figure \ref{DataEncryptionStandard} shows the Data Encryption Standard.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=.4]{DataEncryptionStandard.png}
\caption{The Data Encryption Standard}
\label{DataEncryptionStandard}
\end{center}
\end{figure}

\paragraph{DES Decryption}
Since DES has a Feistel cipher structure, it follows that its decryption algorithm uses the same algorithm as its encryption algorithm, except that the application of the subkey is reversed.\cite{stallings2011}

\paragraph{Attacks on DES}
It was no secret that DES was bombarded with a lot of protests regarding its small key space. A lot of its critics tried to prove that DES was not a very strong encryption algorithm. Discussed here are some of the attacks made on DES.

\subparagraph{Differential Cryptanalysis}
Pioneered by Eli Biham and Adi Shamir, differential cryptanalysis attack requires only examining $2^{47}$ texts which is lower than the $2^{56}$ required in the exhaustive search. As described by Landau\cite{landau2000}, Biham and Shamir's attack on DES is:

\begin{enumerate}
\item Pick an appropriate difference $\Delta X$.
\item Create an appropriate number of plaintext pairs with this $\Delta X$, encrypt with DES, and store the ciphertext pairs.
\item For each pair, from the plaintext $\Delta X$ and the ciphertext pair, determine the expected output difference of as many S-boxes in the last round as possible.
\item For each possible key value, count the number of pairs that result with the expected output change using the value in the last DES round.
\item The right key value is the one suggested by all the key pairs.
\end{enumerate}

\subparagraph{Linear Cryptanalysis}
The seemingly simple and unanticipated Linear Cryptanalysis attack was developed by Mitsuru Matsui. Its objective is to find an effective linear equation of the form\cite{landau2000}:\\
$P[\alpha_{1}\alpha_{2}\cdots,\alpha_{3}] \, \oplus \, C[\beta_{1}\beta_{2}\cdots,\beta_{3}] = K[\gamma_{1}\gamma_{2}\cdots,\gamma_{3}]$

Matsui determined the best linear approximate expressions for DES until 20 rounds. He then used a combination of reduced-rounds linear approximation and exhaustive search to get the key. On the average, the attack requires $2^{43}$ known plaintexts. In 1994, this attack broke a DES-encoded message in 50 days.\cite{stallings2011}

\subsubsection{Advanced Encryption Standard (AES)}
As discussed by Stallings\cite{stallings2011}, AES was first published in 2001 by the National Standards and Technology (NIST) to replace Data Encryption Standard as the approved standard for commercial purposes. The winning algorithm was first known as the Rijndael Block Cipher proposed by Joan Daemen and Vincent Rijmen. AES is a symmetric block cipher that uses a 128b block size and 128, 192, or 56 bit key size. AES do not follow the Feistel structure but each round consists of four different functions:byte substitution, permutation, arithmetic operations over a final field, and XOR with a key. AES also operates in 8-b bytes and the four fundamental operations--addition, subtraction, multiplication and division are all defined over the finite field GF($2^{8}$). Addition of two bytes is defined as XOR operation. Multiplication of two bytes is defined as the multiplication of polynomials modulo an irreducible polynomial of degree 8, $m(x)=x^{8}+x^{4}+x^{3}+x+1$.

\paragraph{AES Encryption}
As cited by Stallings\cite{stallings2011}, the input for the encryption and decryption algorithms is a single 128b  block which is depicted as a 4x4 matrix of bytes and is copied on a state array modified at each state of encryption and decryption. After the final stage, the state is copied to the output matrix. The key used is also depicted as a square matrix which is then expanded into an array of key schedule words, four bytes each. The ordering of the bytes within the matrix is by column.

The number of rounds(N) in the cipher depends on the length of the key: 10 rounds for 16-B keys, 12 rounds for 24-B, and 14 rounds for 32-B keys. For the first N-1 rounds, there are four distinct transformation functions: SubBytes, ShiftRows, MixColumns, and AddRoundKey. \textit{SubBytes} uses an S-box to perform a byte-by-byte substitution of the block. \textit{ShiftRows} is a simple permutation. \textit{MixColumns} is a substitution that makes use of arithmetic over GF($2^{8}$). \textit{AddRoundKey} is a simple bitwise XOR of the current block with a portion of the expanded key. The final round has  three transformation functions. There is also an initial single transformation (AddRoundKey) before the first round (Round 0). The cipher begins and ends with an AddRoundKey stage since only this stage makes use of the key.

All of the stages are reversible. For the SubBytes, ShiftRows, and  MixColumns, an inverse function is used in the decryption algorithm. In the AddRoundKey stage, the inverse is determined by performing an XOR operation between the same round key to the block, using the result that $A\oplus B\oplus B = A$.

Figures \ref{AESEncryptionRound} and \ref{AESEncryptionAndDecryption} shows an AES Encryption Round and the AES encryption and decryption respectively.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.6]{AESEncryptionRound.png}
\caption{AES Encryption Round}
\label{AESEncryptionRound}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=.6]{AESEncryptionAndDecryption.png}
\caption{AES Encryption and Decryption}
\label{AESEncryptionAndDecryption}
\end{center}
\end{figure}

\paragraph{AES Decryption}
The decryption algorithm uses the expanded key in reverse order but is not identical to the encryption algorithm. \cite{stallings2011}

\paragraph{AES vs Known Attacks}
As discussed by Daemen and Rijmen\cite{daemen1999}, here are some of the known attacks during the writing of the Rijndael Block Cipher Proposal.

\subparagraph{Symmetry properties and weak keys of the DES type}
The cipher and its inverse have different components, eliminating the the possibility of weak or semi-weak keys of DES type. Equivalent keys are prevented by the non-linearity of the key expansion.

\subparagraph{Differential Cryptanalysis}
Differential Cryptanalysis Attacks are possible if the prop ratio is significantly larger than $2^{1-n}$ where n is the block length. AES has no 4-round differential trails with a prop ratio above $2^{-150}$.

\subparagraph{Linear Cryptanalysis}
Linear Cryptanalysis Attacks are possible if there are linear trails with correlation coefficients greater than $2^{n/2}$. AES has no 4-round linear trails with correlation greater than $2^{-75}$.

\subparagraph{Truncated Differentials}
Truncated Differentials are possible when the number of differential trails for certain sets of input difference patterns and output difference patterns is very large. Since AES meets the condition for truncated differentials to occur, all transformations operating on bytes were investigated. For six or more rounds, no attacks faster than exhaustive key search were found.

\subparagraph{The Square Attack}
The Square attack is an attack dedicated to the Square. It takes advantage of the byte-oriented structure of Square Ciphers. AES inherits many properties form Square cipher therefor AES is also vulnerable to this type of attack.

The Square attack is found to be faster than exhaustive key search but experiments also showed that there were no extensions to 7 rounds faster than exhaustive key search.

\subparagraph{Interpolation Attacks}
Interpolation attacks are feasible if the cipher components have a compact algebraic expression and can be mixed to provide expressions with manageable complexity. AES prevents these attacks (for more than a few rounds) through its complicated expression of the S-box in GF($2^{8}$) together with the effect of diffusion layer.

\subparagraph{Weak Keys as in IDEA}
These weak keys typically occur in ciphers with non-linear operations depending on the actual key value. In AES, weak keys are prevented by applying the keys using EXOR and putting all non-linearity in the S-box.

\subparagraph{Related-key attacks}
Related-key attacks can be achieved through using different keys with a chosen relation in different cipher operations. This attack is prevented by AES through its high diffusion and non-linearity.

\paragraph{Limitations of AES}
As discussed by Daemen and Rijmen\cite{daemen1999}, here are some of the known limitations of the AES.
\begin{itemize}
\item Since the inverse cipher takes moire code and cycles, the inverse cipher is less likely to be implemented on a smart card than the cipher itself.
\item The cipher and its inverse has different codes and/or tables.
\item The inverse cipher cannot fully re-use the circuitry implementing the cipher.
\end{itemize}

\subsubsection{Stream Ciphers}
Stream ciphers typically encrypts plaintext one byte at a time, although may differ depending on the design. In the structure of the stream ciphers, a key is input to a pseudo-random bit generator that produces a stream of 8-bit random numbers. This stream of random numbers is called a \textbf{keystream} which is combined one byte at a time with the plaintext using the bit-wise exclusive-OR (XOR) operation \cite{stallings2011}. For example:
\\

encrypt
\begin{tabular}{r l}
11001100 & plaintext\\
$\oplus$ 01101100 & key stream\\
\hline
10100000 & ciphertext
\end{tabular}
\\
\\

decrypt
\begin{tabular}{r l}
10100000 & ciphertext\\
$\oplus$ 01101100 & key stream\\
\hline
11001100 & plaintext
\end{tabular}
\\

A stream cipher can be as secure as a block cipher of comparable length if used with a properly designed pseudo-random number generator.

\subsubsection{RC4}
RC4 is a stream cipher designed by Ron Rivest of RSA Security in 1987. It is used in the Secure Sockets Layer/Transport Layer Security (SSL/TLS) standards that have been defined for communication between Web browsers and servers. It is also used in the Wired Equivalent Privacy (WEP) protocol and WiFi Protected Access (WPA) protocol that are part of the IEEE 802.11 wireless LAN standard \cite{stallings2011}.

A variable-length key of from 1 to 256 bytes is used to initialize a 256-byte state table \cite{mousa2006}. The state table is used for subsequent generation of pseudo-random bits and then to generate a pseudo-random stream which is XORed with the plaintext to give the ciphertext.

The algorithm can be broken into two stages: initialization and operation. In the initialization stage, the state table \textbf{S} is populated using \textbf{K} as a seed. Once the state table is initialized, it continues to be modified in a systematic pattern as data is encrypted. The initialization process is summarized in the pseudocode below:

\begin{algorithmic}
\State $j = 0$
\For{$i = 0 \to 255$}
	\State $S[i] = i$
\EndFor
\State $j = 0$
\For{$i = 0 \to 255$}
	\State $j = (j + S[i] + K[i]) mod 256$
	\State $swap(S[i], S[j])$
\EndFor
\end{algorithmic}

Stream generation involves cycling through all the elements of the state table, and for each S[i], swapping S[i] with another byte in \textbf{S} according to a scheme dictated by the current configuration of \textbf{S}. After S[255], the process continues starting over again at S[0].

\begin{algorithmic}
\State $i, j = 0$
\While{$true$}
	\State $i = (i + 1) mod 256$
	\State $j = (j + S[i]) mod 256$
	\State $swap(S[i], S[j])$
	\State $t = (S[i] + S[j]) mod 256$
	\State $k = S[t]$
\EndWhile
\end{algorithmic}

To encrypt, XOR the value \textit{k} with the next byte of plaintext. To decrypt, XOR the value \textit{k} with the next byte of ciphertext.

According to Mousa and Hamad \cite{mousa2006}, the speed of encryption or decryption time for RC4 is directly related to the encryption key length and to the data file size.

\bibliographystyle{unsrt}
\bibliography{references}
\nocite{*}

\end{document}